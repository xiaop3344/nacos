// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: networking/v1alpha3/service_entry.proto

package istio.networking.v1alpha3;

public final class ServiceEntryOuterClass {
  private ServiceEntryOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ServiceEntryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:istio.networking.v1alpha3.ServiceEntry)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return A list containing the hosts.
     */
    java.util.List<java.lang.String>
        getHostsList();
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The count of hosts.
     */
    int getHostsCount();
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index of the element to return.
     * @return The hosts at the given index.
     */
    java.lang.String getHosts(int index);
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index of the value to return.
     * @return The bytes of the hosts at the given index.
     */
    com.google.protobuf.ByteString
        getHostsBytes(int index);

    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return A list containing the addresses.
     */
    java.util.List<java.lang.String>
        getAddressesList();
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return The count of addresses.
     */
    int getAddressesCount();
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index of the element to return.
     * @return The addresses at the given index.
     */
    java.lang.String getAddresses(int index);
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the addresses at the given index.
     */
    com.google.protobuf.ByteString
        getAddressesBytes(int index);

    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    java.util.List<istio.networking.v1alpha3.GatewayOuterClass.Port> 
        getPortsList();
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    istio.networking.v1alpha3.GatewayOuterClass.Port getPorts(int index);
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    int getPortsCount();
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    java.util.List<? extends istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder> 
        getPortsOrBuilderList();
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder getPortsOrBuilder(
        int index);

    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return The enum numeric value on the wire for location.
     */
    int getLocationValue();
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return The location.
     */
    istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location getLocation();

    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The enum numeric value on the wire for resolution.
     */
    int getResolutionValue();
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The resolution.
     */
    istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution getResolution();

    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    java.util.List<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry> 
        getEndpointsList();
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry getEndpoints(int index);
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    int getEndpointsCount();
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    java.util.List<? extends istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder> 
        getEndpointsOrBuilderList();
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder getEndpointsOrBuilder(
        int index);

    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     * @return Whether the workloadSelector field is set.
     */
    boolean hasWorkloadSelector();
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     * @return The workloadSelector.
     */
    istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector getWorkloadSelector();
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelectorOrBuilder getWorkloadSelectorOrBuilder();

    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return A list containing the exportTo.
     */
    java.util.List<java.lang.String>
        getExportToList();
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return The count of exportTo.
     */
    int getExportToCount();
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index of the element to return.
     * @return The exportTo at the given index.
     */
    java.lang.String getExportTo(int index);
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the exportTo at the given index.
     */
    com.google.protobuf.ByteString
        getExportToBytes(int index);

    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return A list containing the subjectAltNames.
     */
    java.util.List<java.lang.String>
        getSubjectAltNamesList();
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return The count of subjectAltNames.
     */
    int getSubjectAltNamesCount();
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index of the element to return.
     * @return The subjectAltNames at the given index.
     */
    java.lang.String getSubjectAltNames(int index);
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the subjectAltNames at the given index.
     */
    com.google.protobuf.ByteString
        getSubjectAltNamesBytes(int index);
  }
  /**
   * <pre>
   * ServiceEntry enables adding additional entries into Istio's internal
   * service registry.
   * &lt;!-- crd generation tags
   * +cue-gen:ServiceEntry:groupName:networking.istio.io
   * +cue-gen:ServiceEntry:version:v1alpha3
   * +cue-gen:ServiceEntry:storageVersion
   * +cue-gen:ServiceEntry:annotations:helm.sh/resource-policy=keep
   * +cue-gen:ServiceEntry:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
   * +cue-gen:ServiceEntry:subresource:status
   * +cue-gen:ServiceEntry:scope:Namespaced
   * +cue-gen:ServiceEntry:resource:categories=istio-io,networking-istio-io,shortNames=se,plural=serviceentries
   * +cue-gen:ServiceEntry:printerColumn:name=Hosts,type=string,JSONPath=.spec.hosts,description="The hosts associated with the ServiceEntry"
   * +cue-gen:ServiceEntry:printerColumn:name=Location,type=string,JSONPath=.spec.location,description="Whether the service is external to the
   * mesh or part of the mesh (MESH_EXTERNAL or MESH_INTERNAL)"
   * +cue-gen:ServiceEntry:printerColumn:name=Resolution,type=string,JSONPath=.spec.resolution,description="Service discovery mode for the hosts
   * (NONE, STATIC, or DNS)"
   * +cue-gen:ServiceEntry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
   * representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
   * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
   * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
   * +cue-gen:ServiceEntry:preserveUnknownFields:false
   * --&gt;
   * &lt;!-- go code generation tags
   * +kubetype-gen
   * +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
   * +genclient
   * +k8s:deepcopy-gen=true
   * --&gt;
   * </pre>
   *
   * Protobuf type {@code istio.networking.v1alpha3.ServiceEntry}
   */
  public static final class ServiceEntry extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:istio.networking.v1alpha3.ServiceEntry)
      ServiceEntryOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ServiceEntry.newBuilder() to construct.
    private ServiceEntry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ServiceEntry() {
      hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      ports_ = java.util.Collections.emptyList();
      location_ = 0;
      resolution_ = 0;
      endpoints_ = java.util.Collections.emptyList();
      exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ServiceEntry();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return istio.networking.v1alpha3.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return istio.networking.v1alpha3.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.class, istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Builder.class);
    }

    /**
     * <pre>
     * Location specifies whether the service is part of Istio mesh or
     * outside the mesh.  Location determines the behavior of several
     * features, such as service-to-service mTLS authentication, policy
     * enforcement, etc. When communicating with services outside the mesh,
     * Istio's mTLS authentication is disabled, and policy enforcement is
     * performed on the client-side as opposed to server-side.
     * </pre>
     *
     * Protobuf enum {@code istio.networking.v1alpha3.ServiceEntry.Location}
     */
    public enum Location
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Signifies that the service is external to the mesh. Typically used
       * to indicate external services consumed through APIs.
       * </pre>
       *
       * <code>MESH_EXTERNAL = 0;</code>
       */
      MESH_EXTERNAL(0),
      /**
       * <pre>
       * Signifies that the service is part of the mesh. Typically used to
       * indicate services added explicitly as part of expanding the service
       * mesh to include unmanaged infrastructure (e.g., VMs added to a
       * Kubernetes based service mesh).
       * </pre>
       *
       * <code>MESH_INTERNAL = 1;</code>
       */
      MESH_INTERNAL(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Signifies that the service is external to the mesh. Typically used
       * to indicate external services consumed through APIs.
       * </pre>
       *
       * <code>MESH_EXTERNAL = 0;</code>
       */
      public static final int MESH_EXTERNAL_VALUE = 0;
      /**
       * <pre>
       * Signifies that the service is part of the mesh. Typically used to
       * indicate services added explicitly as part of expanding the service
       * mesh to include unmanaged infrastructure (e.g., VMs added to a
       * Kubernetes based service mesh).
       * </pre>
       *
       * <code>MESH_INTERNAL = 1;</code>
       */
      public static final int MESH_INTERNAL_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Location valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Location forNumber(int value) {
        switch (value) {
          case 0: return MESH_EXTERNAL;
          case 1: return MESH_INTERNAL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Location>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Location> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Location>() {
              public Location findValueByNumber(int number) {
                return Location.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.getDescriptor().getEnumTypes().get(0);
      }

      private static final Location[] VALUES = values();

      public static Location valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Location(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:istio.networking.v1alpha3.ServiceEntry.Location)
    }

    /**
     * <pre>
     * Resolution determines how the proxy will resolve the IP addresses of
     * the network endpoints associated with the service, so that it can
     * route to one of them. The resolution mode specified here has no impact
     * on how the application resolves the IP address associated with the
     * service. The application may still have to use DNS to resolve the
     * service to an IP so that the outbound traffic can be captured by the
     * Proxy. Alternatively, for HTTP services, the application could
     * directly communicate with the proxy (e.g., by setting HTTP_PROXY) to
     * talk to these services.
     * </pre>
     *
     * Protobuf enum {@code istio.networking.v1alpha3.ServiceEntry.Resolution}
     */
    public enum Resolution
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Assume that incoming connections have already been resolved (to a
       * specific destination IP address). Such connections are typically
       * routed via the proxy using mechanisms such as IP table REDIRECT/
       * eBPF. After performing any routing related transformations, the
       * proxy will forward the connection to the IP address to which the
       * connection was bound.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <pre>
       * Use the static IP addresses specified in endpoints (see below) as the
       * backing instances associated with the service.
       * </pre>
       *
       * <code>STATIC = 1;</code>
       */
      STATIC(1),
      /**
       * <pre>
       * Attempt to resolve the IP address by querying the ambient DNS,
       * during request processing. If no endpoints are specified, the proxy
       * will resolve the DNS address specified in the hosts field, if
       * wildcards are not used. If endpoints are specified, the DNS
       * addresses specified in the endpoints will be resolved to determine
       * the destination IP address.  DNS resolution cannot be used with Unix
       * domain socket endpoints.
       * </pre>
       *
       * <code>DNS = 2;</code>
       */
      DNS(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Assume that incoming connections have already been resolved (to a
       * specific destination IP address). Such connections are typically
       * routed via the proxy using mechanisms such as IP table REDIRECT/
       * eBPF. After performing any routing related transformations, the
       * proxy will forward the connection to the IP address to which the
       * connection was bound.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <pre>
       * Use the static IP addresses specified in endpoints (see below) as the
       * backing instances associated with the service.
       * </pre>
       *
       * <code>STATIC = 1;</code>
       */
      public static final int STATIC_VALUE = 1;
      /**
       * <pre>
       * Attempt to resolve the IP address by querying the ambient DNS,
       * during request processing. If no endpoints are specified, the proxy
       * will resolve the DNS address specified in the hosts field, if
       * wildcards are not used. If endpoints are specified, the DNS
       * addresses specified in the endpoints will be resolved to determine
       * the destination IP address.  DNS resolution cannot be used with Unix
       * domain socket endpoints.
       * </pre>
       *
       * <code>DNS = 2;</code>
       */
      public static final int DNS_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Resolution valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Resolution forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return STATIC;
          case 2: return DNS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Resolution>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Resolution> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Resolution>() {
              public Resolution findValueByNumber(int number) {
                return Resolution.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.getDescriptor().getEnumTypes().get(1);
      }

      private static final Resolution[] VALUES = values();

      public static Resolution valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Resolution(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:istio.networking.v1alpha3.ServiceEntry.Resolution)
    }

    public static final int HOSTS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList hosts_;
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return A list containing the hosts.
     */
    public com.google.protobuf.ProtocolStringList
        getHostsList() {
      return hosts_;
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The count of hosts.
     */
    public int getHostsCount() {
      return hosts_.size();
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index of the element to return.
     * @return The hosts at the given index.
     */
    public java.lang.String getHosts(int index) {
      return hosts_.get(index);
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index of the value to return.
     * @return The bytes of the hosts at the given index.
     */
    public com.google.protobuf.ByteString
        getHostsBytes(int index) {
      return hosts_.getByteString(index);
    }

    public static final int ADDRESSES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList addresses_;
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return A list containing the addresses.
     */
    public com.google.protobuf.ProtocolStringList
        getAddressesList() {
      return addresses_;
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return The count of addresses.
     */
    public int getAddressesCount() {
      return addresses_.size();
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index of the element to return.
     * @return The addresses at the given index.
     */
    public java.lang.String getAddresses(int index) {
      return addresses_.get(index);
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the addresses at the given index.
     */
    public com.google.protobuf.ByteString
        getAddressesBytes(int index) {
      return addresses_.getByteString(index);
    }

    public static final int PORTS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<istio.networking.v1alpha3.GatewayOuterClass.Port> ports_;
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    @java.lang.Override
    public java.util.List<istio.networking.v1alpha3.GatewayOuterClass.Port> getPortsList() {
      return ports_;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    @java.lang.Override
    public java.util.List<? extends istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder> 
        getPortsOrBuilderList() {
      return ports_;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    @java.lang.Override
    public int getPortsCount() {
      return ports_.size();
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    @java.lang.Override
    public istio.networking.v1alpha3.GatewayOuterClass.Port getPorts(int index) {
      return ports_.get(index);
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    @java.lang.Override
    public istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder getPortsOrBuilder(
        int index) {
      return ports_.get(index);
    }

    public static final int LOCATION_FIELD_NUMBER = 4;
    private int location_ = 0;
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return The enum numeric value on the wire for location.
     */
    @java.lang.Override public int getLocationValue() {
      return location_;
    }
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return The location.
     */
    @java.lang.Override public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location getLocation() {
      istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location result = istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location.forNumber(location_);
      return result == null ? istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location.UNRECOGNIZED : result;
    }

    public static final int RESOLUTION_FIELD_NUMBER = 5;
    private int resolution_ = 0;
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The enum numeric value on the wire for resolution.
     */
    @java.lang.Override public int getResolutionValue() {
      return resolution_;
    }
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The resolution.
     */
    @java.lang.Override public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution getResolution() {
      istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution result = istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution.forNumber(resolution_);
      return result == null ? istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution.UNRECOGNIZED : result;
    }

    public static final int ENDPOINTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry> endpoints_;
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    @java.lang.Override
    public java.util.List<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry> getEndpointsList() {
      return endpoints_;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder> 
        getEndpointsOrBuilderList() {
      return endpoints_;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    @java.lang.Override
    public int getEndpointsCount() {
      return endpoints_.size();
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    @java.lang.Override
    public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry getEndpoints(int index) {
      return endpoints_.get(index);
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    @java.lang.Override
    public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder getEndpointsOrBuilder(
        int index) {
      return endpoints_.get(index);
    }

    public static final int WORKLOAD_SELECTOR_FIELD_NUMBER = 9;
    private istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector workloadSelector_;
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     * @return Whether the workloadSelector field is set.
     */
    @java.lang.Override
    public boolean hasWorkloadSelector() {
      return workloadSelector_ != null;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     * @return The workloadSelector.
     */
    @java.lang.Override
    public istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector getWorkloadSelector() {
      return workloadSelector_ == null ? istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.getDefaultInstance() : workloadSelector_;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    @java.lang.Override
    public istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelectorOrBuilder getWorkloadSelectorOrBuilder() {
      return workloadSelector_ == null ? istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.getDefaultInstance() : workloadSelector_;
    }

    public static final int EXPORT_TO_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList exportTo_;
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return A list containing the exportTo.
     */
    public com.google.protobuf.ProtocolStringList
        getExportToList() {
      return exportTo_;
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return The count of exportTo.
     */
    public int getExportToCount() {
      return exportTo_.size();
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index of the element to return.
     * @return The exportTo at the given index.
     */
    public java.lang.String getExportTo(int index) {
      return exportTo_.get(index);
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the exportTo at the given index.
     */
    public com.google.protobuf.ByteString
        getExportToBytes(int index) {
      return exportTo_.getByteString(index);
    }

    public static final int SUBJECT_ALT_NAMES_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList subjectAltNames_;
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return A list containing the subjectAltNames.
     */
    public com.google.protobuf.ProtocolStringList
        getSubjectAltNamesList() {
      return subjectAltNames_;
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return The count of subjectAltNames.
     */
    public int getSubjectAltNamesCount() {
      return subjectAltNames_.size();
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index of the element to return.
     * @return The subjectAltNames at the given index.
     */
    public java.lang.String getSubjectAltNames(int index) {
      return subjectAltNames_.get(index);
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the subjectAltNames at the given index.
     */
    public com.google.protobuf.ByteString
        getSubjectAltNamesBytes(int index) {
      return subjectAltNames_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < hosts_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, hosts_.getRaw(i));
      }
      for (int i = 0; i < addresses_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, addresses_.getRaw(i));
      }
      for (int i = 0; i < ports_.size(); i++) {
        output.writeMessage(3, ports_.get(i));
      }
      if (location_ != istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location.MESH_EXTERNAL.getNumber()) {
        output.writeEnum(4, location_);
      }
      if (resolution_ != istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution.NONE.getNumber()) {
        output.writeEnum(5, resolution_);
      }
      for (int i = 0; i < endpoints_.size(); i++) {
        output.writeMessage(6, endpoints_.get(i));
      }
      for (int i = 0; i < exportTo_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, exportTo_.getRaw(i));
      }
      for (int i = 0; i < subjectAltNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, subjectAltNames_.getRaw(i));
      }
      if (workloadSelector_ != null) {
        output.writeMessage(9, getWorkloadSelector());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < hosts_.size(); i++) {
          dataSize += computeStringSizeNoTag(hosts_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getHostsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < addresses_.size(); i++) {
          dataSize += computeStringSizeNoTag(addresses_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAddressesList().size();
      }
      for (int i = 0; i < ports_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, ports_.get(i));
      }
      if (location_ != istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location.MESH_EXTERNAL.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, location_);
      }
      if (resolution_ != istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution.NONE.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(5, resolution_);
      }
      for (int i = 0; i < endpoints_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, endpoints_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < exportTo_.size(); i++) {
          dataSize += computeStringSizeNoTag(exportTo_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getExportToList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < subjectAltNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(subjectAltNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getSubjectAltNamesList().size();
      }
      if (workloadSelector_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getWorkloadSelector());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry)) {
        return super.equals(obj);
      }
      istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry other = (istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry) obj;

      if (!getHostsList()
          .equals(other.getHostsList())) return false;
      if (!getAddressesList()
          .equals(other.getAddressesList())) return false;
      if (!getPortsList()
          .equals(other.getPortsList())) return false;
      if (location_ != other.location_) return false;
      if (resolution_ != other.resolution_) return false;
      if (!getEndpointsList()
          .equals(other.getEndpointsList())) return false;
      if (hasWorkloadSelector() != other.hasWorkloadSelector()) return false;
      if (hasWorkloadSelector()) {
        if (!getWorkloadSelector()
            .equals(other.getWorkloadSelector())) return false;
      }
      if (!getExportToList()
          .equals(other.getExportToList())) return false;
      if (!getSubjectAltNamesList()
          .equals(other.getSubjectAltNamesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getHostsCount() > 0) {
        hash = (37 * hash) + HOSTS_FIELD_NUMBER;
        hash = (53 * hash) + getHostsList().hashCode();
      }
      if (getAddressesCount() > 0) {
        hash = (37 * hash) + ADDRESSES_FIELD_NUMBER;
        hash = (53 * hash) + getAddressesList().hashCode();
      }
      if (getPortsCount() > 0) {
        hash = (37 * hash) + PORTS_FIELD_NUMBER;
        hash = (53 * hash) + getPortsList().hashCode();
      }
      hash = (37 * hash) + LOCATION_FIELD_NUMBER;
      hash = (53 * hash) + location_;
      hash = (37 * hash) + RESOLUTION_FIELD_NUMBER;
      hash = (53 * hash) + resolution_;
      if (getEndpointsCount() > 0) {
        hash = (37 * hash) + ENDPOINTS_FIELD_NUMBER;
        hash = (53 * hash) + getEndpointsList().hashCode();
      }
      if (hasWorkloadSelector()) {
        hash = (37 * hash) + WORKLOAD_SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getWorkloadSelector().hashCode();
      }
      if (getExportToCount() > 0) {
        hash = (37 * hash) + EXPORT_TO_FIELD_NUMBER;
        hash = (53 * hash) + getExportToList().hashCode();
      }
      if (getSubjectAltNamesCount() > 0) {
        hash = (37 * hash) + SUBJECT_ALT_NAMES_FIELD_NUMBER;
        hash = (53 * hash) + getSubjectAltNamesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ServiceEntry enables adding additional entries into Istio's internal
     * service registry.
     * &lt;!-- crd generation tags
     * +cue-gen:ServiceEntry:groupName:networking.istio.io
     * +cue-gen:ServiceEntry:version:v1alpha3
     * +cue-gen:ServiceEntry:storageVersion
     * +cue-gen:ServiceEntry:annotations:helm.sh/resource-policy=keep
     * +cue-gen:ServiceEntry:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
     * +cue-gen:ServiceEntry:subresource:status
     * +cue-gen:ServiceEntry:scope:Namespaced
     * +cue-gen:ServiceEntry:resource:categories=istio-io,networking-istio-io,shortNames=se,plural=serviceentries
     * +cue-gen:ServiceEntry:printerColumn:name=Hosts,type=string,JSONPath=.spec.hosts,description="The hosts associated with the ServiceEntry"
     * +cue-gen:ServiceEntry:printerColumn:name=Location,type=string,JSONPath=.spec.location,description="Whether the service is external to the
     * mesh or part of the mesh (MESH_EXTERNAL or MESH_INTERNAL)"
     * +cue-gen:ServiceEntry:printerColumn:name=Resolution,type=string,JSONPath=.spec.resolution,description="Service discovery mode for the hosts
     * (NONE, STATIC, or DNS)"
     * +cue-gen:ServiceEntry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
     * representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
     * +cue-gen:ServiceEntry:preserveUnknownFields:false
     * --&gt;
     * &lt;!-- go code generation tags
     * +kubetype-gen
     * +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
     * +genclient
     * +k8s:deepcopy-gen=true
     * --&gt;
     * </pre>
     *
     * Protobuf type {@code istio.networking.v1alpha3.ServiceEntry}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:istio.networking.v1alpha3.ServiceEntry)
        istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return istio.networking.v1alpha3.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return istio.networking.v1alpha3.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.class, istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Builder.class);
      }

      // Construct using istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        if (portsBuilder_ == null) {
          ports_ = java.util.Collections.emptyList();
        } else {
          ports_ = null;
          portsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        location_ = 0;
        resolution_ = 0;
        if (endpointsBuilder_ == null) {
          endpoints_ = java.util.Collections.emptyList();
        } else {
          endpoints_ = null;
          endpointsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        workloadSelector_ = null;
        if (workloadSelectorBuilder_ != null) {
          workloadSelectorBuilder_.dispose();
          workloadSelectorBuilder_ = null;
        }
        exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return istio.networking.v1alpha3.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
      }

      @java.lang.Override
      public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry getDefaultInstanceForType() {
        return istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.getDefaultInstance();
      }

      @java.lang.Override
      public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry build() {
        istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry buildPartial() {
        istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry result = new istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry result) {
        if (((bitField0_ & 0x00000001) != 0)) {
          hosts_ = hosts_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.hosts_ = hosts_;
        if (((bitField0_ & 0x00000002) != 0)) {
          addresses_ = addresses_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.addresses_ = addresses_;
        if (portsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            ports_ = java.util.Collections.unmodifiableList(ports_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.ports_ = ports_;
        } else {
          result.ports_ = portsBuilder_.build();
        }
        if (endpointsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            endpoints_ = java.util.Collections.unmodifiableList(endpoints_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.endpoints_ = endpoints_;
        } else {
          result.endpoints_ = endpointsBuilder_.build();
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          exportTo_ = exportTo_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.exportTo_ = exportTo_;
        if (((bitField0_ & 0x00000100) != 0)) {
          subjectAltNames_ = subjectAltNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.subjectAltNames_ = subjectAltNames_;
      }

      private void buildPartial0(istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.location_ = location_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.resolution_ = resolution_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.workloadSelector_ = workloadSelectorBuilder_ == null
              ? workloadSelector_
              : workloadSelectorBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry) {
          return mergeFrom((istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry other) {
        if (other == istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.getDefaultInstance()) return this;
        if (!other.hosts_.isEmpty()) {
          if (hosts_.isEmpty()) {
            hosts_ = other.hosts_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureHostsIsMutable();
            hosts_.addAll(other.hosts_);
          }
          onChanged();
        }
        if (!other.addresses_.isEmpty()) {
          if (addresses_.isEmpty()) {
            addresses_ = other.addresses_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureAddressesIsMutable();
            addresses_.addAll(other.addresses_);
          }
          onChanged();
        }
        if (portsBuilder_ == null) {
          if (!other.ports_.isEmpty()) {
            if (ports_.isEmpty()) {
              ports_ = other.ports_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensurePortsIsMutable();
              ports_.addAll(other.ports_);
            }
            onChanged();
          }
        } else {
          if (!other.ports_.isEmpty()) {
            if (portsBuilder_.isEmpty()) {
              portsBuilder_.dispose();
              portsBuilder_ = null;
              ports_ = other.ports_;
              bitField0_ = (bitField0_ & ~0x00000004);
              portsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPortsFieldBuilder() : null;
            } else {
              portsBuilder_.addAllMessages(other.ports_);
            }
          }
        }
        if (other.location_ != 0) {
          setLocationValue(other.getLocationValue());
        }
        if (other.resolution_ != 0) {
          setResolutionValue(other.getResolutionValue());
        }
        if (endpointsBuilder_ == null) {
          if (!other.endpoints_.isEmpty()) {
            if (endpoints_.isEmpty()) {
              endpoints_ = other.endpoints_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureEndpointsIsMutable();
              endpoints_.addAll(other.endpoints_);
            }
            onChanged();
          }
        } else {
          if (!other.endpoints_.isEmpty()) {
            if (endpointsBuilder_.isEmpty()) {
              endpointsBuilder_.dispose();
              endpointsBuilder_ = null;
              endpoints_ = other.endpoints_;
              bitField0_ = (bitField0_ & ~0x00000020);
              endpointsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEndpointsFieldBuilder() : null;
            } else {
              endpointsBuilder_.addAllMessages(other.endpoints_);
            }
          }
        }
        if (other.hasWorkloadSelector()) {
          mergeWorkloadSelector(other.getWorkloadSelector());
        }
        if (!other.exportTo_.isEmpty()) {
          if (exportTo_.isEmpty()) {
            exportTo_ = other.exportTo_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureExportToIsMutable();
            exportTo_.addAll(other.exportTo_);
          }
          onChanged();
        }
        if (!other.subjectAltNames_.isEmpty()) {
          if (subjectAltNames_.isEmpty()) {
            subjectAltNames_ = other.subjectAltNames_;
            bitField0_ = (bitField0_ & ~0x00000100);
          } else {
            ensureSubjectAltNamesIsMutable();
            subjectAltNames_.addAll(other.subjectAltNames_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureHostsIsMutable();
                hosts_.add(s);
                break;
              } // case 10
              case 18: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureAddressesIsMutable();
                addresses_.add(s);
                break;
              } // case 18
              case 26: {
                istio.networking.v1alpha3.GatewayOuterClass.Port m =
                    input.readMessage(
                        istio.networking.v1alpha3.GatewayOuterClass.Port.parser(),
                        extensionRegistry);
                if (portsBuilder_ == null) {
                  ensurePortsIsMutable();
                  ports_.add(m);
                } else {
                  portsBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 32: {
                location_ = input.readEnum();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                resolution_ = input.readEnum();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry m =
                    input.readMessage(
                        istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.parser(),
                        extensionRegistry);
                if (endpointsBuilder_ == null) {
                  ensureEndpointsIsMutable();
                  endpoints_.add(m);
                } else {
                  endpointsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 58: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureExportToIsMutable();
                exportTo_.add(s);
                break;
              } // case 58
              case 66: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubjectAltNamesIsMutable();
                subjectAltNames_.add(s);
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getWorkloadSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 74
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureHostsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          hosts_ = new com.google.protobuf.LazyStringArrayList(hosts_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @return A list containing the hosts.
       */
      public com.google.protobuf.ProtocolStringList
          getHostsList() {
        return hosts_.getUnmodifiableView();
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @return The count of hosts.
       */
      public int getHostsCount() {
        return hosts_.size();
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param index The index of the element to return.
       * @return The hosts at the given index.
       */
      public java.lang.String getHosts(int index) {
        return hosts_.get(index);
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param index The index of the value to return.
       * @return The bytes of the hosts at the given index.
       */
      public com.google.protobuf.ByteString
          getHostsBytes(int index) {
        return hosts_.getByteString(index);
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param index The index to set the value at.
       * @param value The hosts to set.
       * @return This builder for chaining.
       */
      public Builder setHosts(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureHostsIsMutable();
        hosts_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param value The hosts to add.
       * @return This builder for chaining.
       */
      public Builder addHosts(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureHostsIsMutable();
        hosts_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param values The hosts to add.
       * @return This builder for chaining.
       */
      public Builder addAllHosts(
          java.lang.Iterable<java.lang.String> values) {
        ensureHostsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, hosts_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @return This builder for chaining.
       */
      public Builder clearHosts() {
        hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hosts associated with the ServiceEntry. Could be a DNS
       * name with wildcard prefix.
       * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
       * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
       * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
       * will be matched against the hosts field.
       * **NOTE 1:** When resolution is set to type DNS and no endpoints
       * are specified, the host field will be used as the DNS name of the
       * endpoint to route traffic to.
       * **NOTE 2:** If the hostname matches with the name of a service
       * from another service registry such as Kubernetes that also
       * supplies its own set of endpoints, the ServiceEntry will be
       * treated as a decorator of the existing Kubernetes
       * service. Properties in the service entry will be added to the
       * Kubernetes service if applicable. Currently, the only the
       * following additional properties will be considered by `istiod`:
       * 1. subjectAltNames: In addition to verifying the SANs of the
       *    service accounts associated with the pods of the service, the
       *    SANs specified here will also be verified.
       * </pre>
       *
       * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param value The bytes of the hosts to add.
       * @return This builder for chaining.
       */
      public Builder addHostsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureHostsIsMutable();
        hosts_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAddressesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          addresses_ = new com.google.protobuf.LazyStringArrayList(addresses_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @return A list containing the addresses.
       */
      public com.google.protobuf.ProtocolStringList
          getAddressesList() {
        return addresses_.getUnmodifiableView();
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @return The count of addresses.
       */
      public int getAddressesCount() {
        return addresses_.size();
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @param index The index of the element to return.
       * @return The addresses at the given index.
       */
      public java.lang.String getAddresses(int index) {
        return addresses_.get(index);
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the addresses at the given index.
       */
      public com.google.protobuf.ByteString
          getAddressesBytes(int index) {
        return addresses_.getByteString(index);
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @param index The index to set the value at.
       * @param value The addresses to set.
       * @return This builder for chaining.
       */
      public Builder setAddresses(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAddressesIsMutable();
        addresses_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @param value The addresses to add.
       * @return This builder for chaining.
       */
      public Builder addAddresses(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAddressesIsMutable();
        addresses_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @param values The addresses to add.
       * @return This builder for chaining.
       */
      public Builder addAllAddresses(
          java.lang.Iterable<java.lang.String> values) {
        ensureAddressesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, addresses_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddresses() {
        addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The virtual IP addresses associated with the service. Could be CIDR
       * prefix. For HTTP traffic, generated route configurations will include http route
       * domains for both the `addresses` and `hosts` field values and the destination will
       * be identified based on the HTTP Host/Authority header.
       * If one or more IP addresses are specified,
       * the incoming traffic will be identified as belonging to this service
       * if the destination IP matches the IP/CIDRs specified in the addresses
       * field. If the Addresses field is empty, traffic will be identified
       * solely based on the destination port. In such scenarios, the port on
       * which the service is being accessed must not be shared by any other
       * service in the mesh. In other words, the sidecar will behave as a
       * simple TCP proxy, forwarding incoming traffic on a specified port to
       * the specified destination endpoint IP/host. Unix domain socket
       * addresses are not supported in this field.
       * </pre>
       *
       * <code>repeated string addresses = 2;</code>
       * @param value The bytes of the addresses to add.
       * @return This builder for chaining.
       */
      public Builder addAddressesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureAddressesIsMutable();
        addresses_.add(value);
        onChanged();
        return this;
      }

      private java.util.List<istio.networking.v1alpha3.GatewayOuterClass.Port> ports_ =
        java.util.Collections.emptyList();
      private void ensurePortsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          ports_ = new java.util.ArrayList<istio.networking.v1alpha3.GatewayOuterClass.Port>(ports_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          istio.networking.v1alpha3.GatewayOuterClass.Port, istio.networking.v1alpha3.GatewayOuterClass.Port.Builder, istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder> portsBuilder_;

      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public java.util.List<istio.networking.v1alpha3.GatewayOuterClass.Port> getPortsList() {
        if (portsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ports_);
        } else {
          return portsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public int getPortsCount() {
        if (portsBuilder_ == null) {
          return ports_.size();
        } else {
          return portsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public istio.networking.v1alpha3.GatewayOuterClass.Port getPorts(int index) {
        if (portsBuilder_ == null) {
          return ports_.get(index);
        } else {
          return portsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder setPorts(
          int index, istio.networking.v1alpha3.GatewayOuterClass.Port value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.set(index, value);
          onChanged();
        } else {
          portsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder setPorts(
          int index, istio.networking.v1alpha3.GatewayOuterClass.Port.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.set(index, builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder addPorts(istio.networking.v1alpha3.GatewayOuterClass.Port value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.add(value);
          onChanged();
        } else {
          portsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder addPorts(
          int index, istio.networking.v1alpha3.GatewayOuterClass.Port value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.add(index, value);
          onChanged();
        } else {
          portsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder addPorts(
          istio.networking.v1alpha3.GatewayOuterClass.Port.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.add(builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder addPorts(
          int index, istio.networking.v1alpha3.GatewayOuterClass.Port.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.add(index, builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder addAllPorts(
          java.lang.Iterable<? extends istio.networking.v1alpha3.GatewayOuterClass.Port> values) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, ports_);
          onChanged();
        } else {
          portsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder clearPorts() {
        if (portsBuilder_ == null) {
          ports_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          portsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public Builder removePorts(int index) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.remove(index);
          onChanged();
        } else {
          portsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public istio.networking.v1alpha3.GatewayOuterClass.Port.Builder getPortsBuilder(
          int index) {
        return getPortsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder getPortsOrBuilder(
          int index) {
        if (portsBuilder_ == null) {
          return ports_.get(index);  } else {
          return portsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public java.util.List<? extends istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder> 
           getPortsOrBuilderList() {
        if (portsBuilder_ != null) {
          return portsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ports_);
        }
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public istio.networking.v1alpha3.GatewayOuterClass.Port.Builder addPortsBuilder() {
        return getPortsFieldBuilder().addBuilder(
            istio.networking.v1alpha3.GatewayOuterClass.Port.getDefaultInstance());
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public istio.networking.v1alpha3.GatewayOuterClass.Port.Builder addPortsBuilder(
          int index) {
        return getPortsFieldBuilder().addBuilder(
            index, istio.networking.v1alpha3.GatewayOuterClass.Port.getDefaultInstance());
      }
      /**
       * <pre>
       * The ports associated with the external service. If the
       * Endpoints are Unix domain socket addresses, there must be exactly one
       * port.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
       */
      public java.util.List<istio.networking.v1alpha3.GatewayOuterClass.Port.Builder> 
           getPortsBuilderList() {
        return getPortsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          istio.networking.v1alpha3.GatewayOuterClass.Port, istio.networking.v1alpha3.GatewayOuterClass.Port.Builder, istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder> 
          getPortsFieldBuilder() {
        if (portsBuilder_ == null) {
          portsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              istio.networking.v1alpha3.GatewayOuterClass.Port, istio.networking.v1alpha3.GatewayOuterClass.Port.Builder, istio.networking.v1alpha3.GatewayOuterClass.PortOrBuilder>(
                  ports_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          ports_ = null;
        }
        return portsBuilder_;
      }

      private int location_ = 0;
      /**
       * <pre>
       * Specify whether the service should be considered external to the mesh
       * or part of the mesh.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
       * @return The enum numeric value on the wire for location.
       */
      @java.lang.Override public int getLocationValue() {
        return location_;
      }
      /**
       * <pre>
       * Specify whether the service should be considered external to the mesh
       * or part of the mesh.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
       * @param value The enum numeric value on the wire for location to set.
       * @return This builder for chaining.
       */
      public Builder setLocationValue(int value) {
        location_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specify whether the service should be considered external to the mesh
       * or part of the mesh.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
       * @return The location.
       */
      @java.lang.Override
      public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location getLocation() {
        istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location result = istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location.forNumber(location_);
        return result == null ? istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Specify whether the service should be considered external to the mesh
       * or part of the mesh.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
       * @param value The location to set.
       * @return This builder for chaining.
       */
      public Builder setLocation(istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Location value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        location_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specify whether the service should be considered external to the mesh
       * or part of the mesh.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocation() {
        bitField0_ = (bitField0_ & ~0x00000008);
        location_ = 0;
        onChanged();
        return this;
      }

      private int resolution_ = 0;
      /**
       * <pre>
       * Service discovery mode for the hosts. Care must be taken
       * when setting the resolution mode to NONE for a TCP port without
       * accompanying IP addresses. In such cases, traffic to any IP on
       * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
       * @return The enum numeric value on the wire for resolution.
       */
      @java.lang.Override public int getResolutionValue() {
        return resolution_;
      }
      /**
       * <pre>
       * Service discovery mode for the hosts. Care must be taken
       * when setting the resolution mode to NONE for a TCP port without
       * accompanying IP addresses. In such cases, traffic to any IP on
       * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param value The enum numeric value on the wire for resolution to set.
       * @return This builder for chaining.
       */
      public Builder setResolutionValue(int value) {
        resolution_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Service discovery mode for the hosts. Care must be taken
       * when setting the resolution mode to NONE for a TCP port without
       * accompanying IP addresses. In such cases, traffic to any IP on
       * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
       * @return The resolution.
       */
      @java.lang.Override
      public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution getResolution() {
        istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution result = istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution.forNumber(resolution_);
        return result == null ? istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Service discovery mode for the hosts. Care must be taken
       * when setting the resolution mode to NONE for a TCP port without
       * accompanying IP addresses. In such cases, traffic to any IP on
       * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
       * @param value The resolution to set.
       * @return This builder for chaining.
       */
      public Builder setResolution(istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry.Resolution value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        resolution_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Service discovery mode for the hosts. Care must be taken
       * when setting the resolution mode to NONE for a TCP port without
       * accompanying IP addresses. In such cases, traffic to any IP on
       * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
       * @return This builder for chaining.
       */
      public Builder clearResolution() {
        bitField0_ = (bitField0_ & ~0x00000010);
        resolution_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry> endpoints_ =
        java.util.Collections.emptyList();
      private void ensureEndpointsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          endpoints_ = new java.util.ArrayList<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry>(endpoints_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder> endpointsBuilder_;

      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public java.util.List<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry> getEndpointsList() {
        if (endpointsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(endpoints_);
        } else {
          return endpointsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public int getEndpointsCount() {
        if (endpointsBuilder_ == null) {
          return endpoints_.size();
        } else {
          return endpointsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry getEndpoints(int index) {
        if (endpointsBuilder_ == null) {
          return endpoints_.get(index);
        } else {
          return endpointsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder setEndpoints(
          int index, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry value) {
        if (endpointsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEndpointsIsMutable();
          endpoints_.set(index, value);
          onChanged();
        } else {
          endpointsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder setEndpoints(
          int index, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder builderForValue) {
        if (endpointsBuilder_ == null) {
          ensureEndpointsIsMutable();
          endpoints_.set(index, builderForValue.build());
          onChanged();
        } else {
          endpointsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder addEndpoints(istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry value) {
        if (endpointsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEndpointsIsMutable();
          endpoints_.add(value);
          onChanged();
        } else {
          endpointsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder addEndpoints(
          int index, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry value) {
        if (endpointsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEndpointsIsMutable();
          endpoints_.add(index, value);
          onChanged();
        } else {
          endpointsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder addEndpoints(
          istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder builderForValue) {
        if (endpointsBuilder_ == null) {
          ensureEndpointsIsMutable();
          endpoints_.add(builderForValue.build());
          onChanged();
        } else {
          endpointsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder addEndpoints(
          int index, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder builderForValue) {
        if (endpointsBuilder_ == null) {
          ensureEndpointsIsMutable();
          endpoints_.add(index, builderForValue.build());
          onChanged();
        } else {
          endpointsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder addAllEndpoints(
          java.lang.Iterable<? extends istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry> values) {
        if (endpointsBuilder_ == null) {
          ensureEndpointsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, endpoints_);
          onChanged();
        } else {
          endpointsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder clearEndpoints() {
        if (endpointsBuilder_ == null) {
          endpoints_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          endpointsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public Builder removeEndpoints(int index) {
        if (endpointsBuilder_ == null) {
          ensureEndpointsIsMutable();
          endpoints_.remove(index);
          onChanged();
        } else {
          endpointsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder getEndpointsBuilder(
          int index) {
        return getEndpointsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder getEndpointsOrBuilder(
          int index) {
        if (endpointsBuilder_ == null) {
          return endpoints_.get(index);  } else {
          return endpointsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public java.util.List<? extends istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder> 
           getEndpointsOrBuilderList() {
        if (endpointsBuilder_ != null) {
          return endpointsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(endpoints_);
        }
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder addEndpointsBuilder() {
        return getEndpointsFieldBuilder().addBuilder(
            istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.getDefaultInstance());
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder addEndpointsBuilder(
          int index) {
        return getEndpointsFieldBuilder().addBuilder(
            index, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.getDefaultInstance());
      }
      /**
       * <pre>
       * One or more endpoints associated with the service. Only one of
       * `endpoints` or `workloadSelector` can be specified.
       * </pre>
       *
       * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
       */
      public java.util.List<istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder> 
           getEndpointsBuilderList() {
        return getEndpointsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder> 
          getEndpointsFieldBuilder() {
        if (endpointsBuilder_ == null) {
          endpointsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntry.Builder, istio.networking.v1alpha3.WorkloadEntryOuterClass.WorkloadEntryOrBuilder>(
                  endpoints_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          endpoints_ = null;
        }
        return endpointsBuilder_;
      }

      private istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector workloadSelector_;
      private com.google.protobuf.SingleFieldBuilderV3<
          istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector, istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.Builder, istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelectorOrBuilder> workloadSelectorBuilder_;
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       * @return Whether the workloadSelector field is set.
       */
      public boolean hasWorkloadSelector() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       * @return The workloadSelector.
       */
      public istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector getWorkloadSelector() {
        if (workloadSelectorBuilder_ == null) {
          return workloadSelector_ == null ? istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.getDefaultInstance() : workloadSelector_;
        } else {
          return workloadSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      public Builder setWorkloadSelector(istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector value) {
        if (workloadSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          workloadSelector_ = value;
        } else {
          workloadSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      public Builder setWorkloadSelector(
          istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.Builder builderForValue) {
        if (workloadSelectorBuilder_ == null) {
          workloadSelector_ = builderForValue.build();
        } else {
          workloadSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      public Builder mergeWorkloadSelector(istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector value) {
        if (workloadSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            workloadSelector_ != null &&
            workloadSelector_ != istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.getDefaultInstance()) {
            getWorkloadSelectorBuilder().mergeFrom(value);
          } else {
            workloadSelector_ = value;
          }
        } else {
          workloadSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      public Builder clearWorkloadSelector() {
        bitField0_ = (bitField0_ & ~0x00000040);
        workloadSelector_ = null;
        if (workloadSelectorBuilder_ != null) {
          workloadSelectorBuilder_.dispose();
          workloadSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      public istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.Builder getWorkloadSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getWorkloadSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      public istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelectorOrBuilder getWorkloadSelectorOrBuilder() {
        if (workloadSelectorBuilder_ != null) {
          return workloadSelectorBuilder_.getMessageOrBuilder();
        } else {
          return workloadSelector_ == null ?
              istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.getDefaultInstance() : workloadSelector_;
        }
      }
      /**
       * <pre>
       * Applicable only for MESH_INTERNAL services. Only one of
       * `endpoints` or `workloadSelector` can be specified. Selects one
       * or more Kubernetes pods or VM workloads (specified using
       * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
       * representing the VMs should be defined in the same namespace as
       * the ServiceEntry.
       * </pre>
       *
       * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector, istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.Builder, istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelectorOrBuilder> 
          getWorkloadSelectorFieldBuilder() {
        if (workloadSelectorBuilder_ == null) {
          workloadSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector, istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelector.Builder, istio.networking.v1alpha3.SidecarOuterClass.WorkloadSelectorOrBuilder>(
                  getWorkloadSelector(),
                  getParentForChildren(),
                  isClean());
          workloadSelector_ = null;
        }
        return workloadSelectorBuilder_;
      }

      private com.google.protobuf.LazyStringList exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureExportToIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          exportTo_ = new com.google.protobuf.LazyStringArrayList(exportTo_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @return A list containing the exportTo.
       */
      public com.google.protobuf.ProtocolStringList
          getExportToList() {
        return exportTo_.getUnmodifiableView();
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @return The count of exportTo.
       */
      public int getExportToCount() {
        return exportTo_.size();
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @param index The index of the element to return.
       * @return The exportTo at the given index.
       */
      public java.lang.String getExportTo(int index) {
        return exportTo_.get(index);
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @param index The index of the value to return.
       * @return The bytes of the exportTo at the given index.
       */
      public com.google.protobuf.ByteString
          getExportToBytes(int index) {
        return exportTo_.getByteString(index);
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @param index The index to set the value at.
       * @param value The exportTo to set.
       * @return This builder for chaining.
       */
      public Builder setExportTo(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExportToIsMutable();
        exportTo_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @param value The exportTo to add.
       * @return This builder for chaining.
       */
      public Builder addExportTo(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExportToIsMutable();
        exportTo_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @param values The exportTo to add.
       * @return This builder for chaining.
       */
      public Builder addAllExportTo(
          java.lang.Iterable<java.lang.String> values) {
        ensureExportToIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, exportTo_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearExportTo() {
        exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of namespaces to which this service is exported. Exporting a service
       * allows it to be used by sidecars, gateways and virtual services defined in
       * other namespaces. This feature provides a mechanism for service owners
       * and mesh administrators to control the visibility of services across
       * namespace boundaries.
       * If no namespaces are specified then the service is exported to all
       * namespaces by default.
       * The value "." is reserved and defines an export to the same namespace that
       * the service is declared in. Similarly the value "*" is reserved and
       * defines an export to all namespaces.
       * For a Kubernetes Service, the equivalent effect can be achieved by setting
       * the annotation "networking.istio.io/exportTo" to a comma-separated list
       * of namespace names.
       * NOTE: in the current release, the `exportTo` value is restricted to
       * "." or "*" (i.e., the current namespace or all namespaces).
       * </pre>
       *
       * <code>repeated string export_to = 7;</code>
       * @param value The bytes of the exportTo to add.
       * @return This builder for chaining.
       */
      public Builder addExportToBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureExportToIsMutable();
        exportTo_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureSubjectAltNamesIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          subjectAltNames_ = new com.google.protobuf.LazyStringArrayList(subjectAltNames_);
          bitField0_ |= 0x00000100;
         }
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @return A list containing the subjectAltNames.
       */
      public com.google.protobuf.ProtocolStringList
          getSubjectAltNamesList() {
        return subjectAltNames_.getUnmodifiableView();
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @return The count of subjectAltNames.
       */
      public int getSubjectAltNamesCount() {
        return subjectAltNames_.size();
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @param index The index of the element to return.
       * @return The subjectAltNames at the given index.
       */
      public java.lang.String getSubjectAltNames(int index) {
        return subjectAltNames_.get(index);
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @param index The index of the value to return.
       * @return The bytes of the subjectAltNames at the given index.
       */
      public com.google.protobuf.ByteString
          getSubjectAltNamesBytes(int index) {
        return subjectAltNames_.getByteString(index);
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @param index The index to set the value at.
       * @param value The subjectAltNames to set.
       * @return This builder for chaining.
       */
      public Builder setSubjectAltNames(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureSubjectAltNamesIsMutable();
        subjectAltNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @param value The subjectAltNames to add.
       * @return This builder for chaining.
       */
      public Builder addSubjectAltNames(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureSubjectAltNamesIsMutable();
        subjectAltNames_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @param values The subjectAltNames to add.
       * @return This builder for chaining.
       */
      public Builder addAllSubjectAltNames(
          java.lang.Iterable<java.lang.String> values) {
        ensureSubjectAltNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, subjectAltNames_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSubjectAltNames() {
        subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the proxy will verify that the server certificate's
       * subject alternate name matches one of the specified values.
       * NOTE: When using the workloadEntry with workloadSelectors, the
       * service account specified in the workloadEntry will also be used
       * to derive the additional subject alternate names that should be
       * verified.
       * </pre>
       *
       * <code>repeated string subject_alt_names = 8;</code>
       * @param value The bytes of the subjectAltNames to add.
       * @return This builder for chaining.
       */
      public Builder addSubjectAltNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureSubjectAltNamesIsMutable();
        subjectAltNames_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:istio.networking.v1alpha3.ServiceEntry)
    }

    // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ServiceEntry)
    private static final istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry();
    }

    public static istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServiceEntry>
        PARSER = new com.google.protobuf.AbstractParser<ServiceEntry>() {
      @java.lang.Override
      public ServiceEntry parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ServiceEntry> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServiceEntry> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public istio.networking.v1alpha3.ServiceEntryOuterClass.ServiceEntry getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_istio_networking_v1alpha3_ServiceEntry_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\'networking/v1alpha3/service_entry.prot" +
      "o\022\031istio.networking.v1alpha3\032\037google/api" +
      "/field_behavior.proto\032!networking/v1alph" +
      "a3/gateway.proto\032!networking/v1alpha3/si" +
      "decar.proto\032(networking/v1alpha3/workloa" +
      "d_entry.proto\"\215\004\n\014ServiceEntry\022\022\n\005hosts\030" +
      "\001 \003(\tB\003\340A\002\022\021\n\taddresses\030\002 \003(\t\0223\n\005ports\030\003" +
      " \003(\0132\037.istio.networking.v1alpha3.PortB\003\340" +
      "A\002\022B\n\010location\030\004 \001(\01620.istio.networking." +
      "v1alpha3.ServiceEntry.Location\022K\n\nresolu" +
      "tion\030\005 \001(\01622.istio.networking.v1alpha3.S" +
      "erviceEntry.ResolutionB\003\340A\002\022;\n\tendpoints" +
      "\030\006 \003(\0132(.istio.networking.v1alpha3.Workl" +
      "oadEntry\022F\n\021workload_selector\030\t \001(\0132+.is" +
      "tio.networking.v1alpha3.WorkloadSelector" +
      "\022\021\n\texport_to\030\007 \003(\t\022\031\n\021subject_alt_names" +
      "\030\010 \003(\t\"0\n\010Location\022\021\n\rMESH_EXTERNAL\020\000\022\021\n" +
      "\rMESH_INTERNAL\020\001\"+\n\nResolution\022\010\n\004NONE\020\000" +
      "\022\n\n\006STATIC\020\001\022\007\n\003DNS\020\002B\"Z istio.io/api/ne" +
      "tworking/v1alpha3b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.api.FieldBehaviorProto.getDescriptor(),
          istio.networking.v1alpha3.GatewayOuterClass.getDescriptor(),
          istio.networking.v1alpha3.SidecarOuterClass.getDescriptor(),
          istio.networking.v1alpha3.WorkloadEntryOuterClass.getDescriptor(),
        });
    internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_istio_networking_v1alpha3_ServiceEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor,
        new java.lang.String[] { "Hosts", "Addresses", "Ports", "Location", "Resolution", "Endpoints", "WorkloadSelector", "ExportTo", "SubjectAltNames", });
    com.google.protobuf.ExtensionRegistry registry =
        com.google.protobuf.ExtensionRegistry.newInstance();
    registry.add(com.google.api.FieldBehaviorProto.fieldBehavior);
    com.google.protobuf.Descriptors.FileDescriptor
        .internalUpdateFileDescriptor(descriptor, registry);
    com.google.api.FieldBehaviorProto.getDescriptor();
    istio.networking.v1alpha3.GatewayOuterClass.getDescriptor();
    istio.networking.v1alpha3.SidecarOuterClass.getDescriptor();
    istio.networking.v1alpha3.WorkloadEntryOuterClass.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
